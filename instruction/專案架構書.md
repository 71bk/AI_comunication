# GPT-like 全端聊天網頁（A → B）專案架構書

> 版本：v1.0  
> 更新日期：2025-12-30  
> 專案目標：先完成 A（MVP：類 ChatGPT 串流聊天），再無痛升級 B（RAG：文件問答＋引用）。  
> 特別約束：**前端不使用 Tailwind**、前端 **Axios 封裝統一錯誤處理**、後端 **Result 統一回傳格式**、後端 **全域統一錯誤管理（Global Exception Handling）**、串流採 **SSE**。

---

## 1. 產品範圍與里程碑

### 1.1 版本 A（MVP）功能
- ✅ 註冊 / 登入 / 登出 / 取得當前使用者（Auth）
- ✅ 對話列表（Chat list）
- ✅ 建立新對話（Create chat）
- ✅ 讀取對話內容（含訊息）（Chat detail）
- ✅ 發送訊息 → 後端呼叫 LLM → **SSE 串流回覆**（像 ChatGPT 打字）
- ✅ 訊息持久化（Message persistence）
- ✅ 前後端統一錯誤格式與處理（含 Validation）
- ✅ 前端 Axios 封裝（baseURL、timeout、interceptor、錯誤正規化）
- （可選）用量紀錄 / Rate limit（可先保留介面，後補實作）

### 1.2 版本 B（升級）功能
- ✅ 文件上傳（PDF/TXT/MD 等）與儲存（S3/R2/本機）
- ✅ 文件解析與 Chunk 切分
- ✅ Embeddings → Vector Store（pgvector/Qdrant/Milvus 等，抽象介面可替換）
- ✅ Chat 時檢索 TopK chunks → 組 Context → 回答帶 citations（引用）
- ✅ SSE 增加 `meta` 事件回傳引用資訊
- ✅ citations 寫入 `messages.metadata_json`（無需改 messages content）

### 1.3 A → B 的「不砍重練」設計原則
- Chat 模組不直接依賴模型供應商 SDK（OpenAI/Claude/Gemini）
- 用 `LlmClient` 介面隔離供應商差異（Adapter）
- Prompt 組裝集中在 `PromptBuilder`
- B 的 RAG 以 `Retriever` 介面插入：`retrieveContext(query) -> promptBuilder.build(messages, context)`
- SSE 協議預先規格化：`delta / meta / done / error`（A 不送 meta 也不影響前端）

---

## 2. 技術選型

### 2.1 前端
- Vue 3 + Vite
- Vue Router
- Pinia
- UI：Element Plus（或同級 UI library）
- CSS：**SCSS**（不使用 Tailwind）  
  - 全域：reset、theme variables、layout primitives  
  - 元件：CSS Modules 或 BEM 命名，避免污染
- HTTP：Axios（封裝 `http.ts` + interceptors）
- Markdown：markdown-it（或 marked）+ code highlight（highlight.js / shiki）
- 串流：SSE（EventSource）或 fetch stream（本書以 SSE 為主）

### 2.2 後端
- Spring Boot 3.x（Web, Validation, Security）
- JPA/Hibernate
- MySQL 8
- Redis（建議：rate limit / usage，A 可先不接）
- 檔案儲存（B）：S3/R2/本機（抽象 StorageClient 介面）
- 向量庫（B）：pgvector / Qdrant / Milvus（抽象 VectorStoreClient 介面）

---

## 3. 系統架構總覽（高維護性 / 低耦合）

### 3.1 模組邊界（建議）
- **auth**：註冊、登入、JWT、使用者資訊
- **chat**：對話與訊息 CRUD、串流回覆流程編排
- **llm**：模型呼叫（供應商 Adapter）、PromptBuilder、串流事件封裝
- **rag（B）**：ingest（解析/切塊/embedding）、retrieve（檢索）、citations 格式化
- **common**：共用工具（traceId、json util、時間、常數）
- **result/exception/handler**：統一回傳與全域錯誤管理

### 3.2 低耦合檢核（你完成 A 後建議逐項對照）
1. Controller 不直接引用供應商 SDK
2. `LlmClient` 有介面 + 至少一個 adapter 實作
3. Prompt 規則集中在 `PromptBuilder`
4. SSE 事件 schema 固定（delta/meta/done/error）
5. `messages` 具備 `metadata_json` 保存擴充資訊
6. GlobalExceptionHandler 統一處理 Validation、Biz、Unknown exceptions
7. B 的 RAG 是新增模組，不修改 chat 核心資料模型

---

## 4. 後端專案目錄結構（對齊你截圖的 package 風格）

> base package：`tw.bk.landing`

```
tw.bk.landing
├─ config
│  ├─ WebConfig
│  ├─ SecurityConfig
│  └─ AppProperties
│
├─ controller
│  ├─ AuthController
│  ├─ ChatController
│  └─ HealthController (optional)
│
├─ dto
│  ├─ auth
│  │  ├─ RegisterReq
│  │  ├─ LoginReq
│  │  └─ AuthMeResp
│  └─ chat
│     ├─ ChatCreateReq
│     ├─ ChatResp
│     ├─ ChatDetailResp
│     ├─ MessageSendReq
│     └─ MessageResp
│
├─ entity
│  ├─ User
│  ├─ Chat
│  ├─ Message
│  └─ (B) Document / Chunk / KnowledgeBase
│
├─ exception
│  ├─ ErrorCode (enum)
│  ├─ BizException
│  ├─ NotFoundException
│  ├─ AuthException
│  └─ RateLimitException
│
├─ filter
│  ├─ TraceIdFilter
│  └─ JwtAuthFilter
│
├─ handler
│  ├─ GlobalExceptionHandler
│  └─ ValidationErrorMapper (optional)
│
├─ repository
│  ├─ UserRepository
│  ├─ ChatRepository
│  └─ MessageRepository
│
├─ result
│  ├─ Result<T>
│  └─ Results (optional)
│
├─ security
│  ├─ JwtProvider
│  ├─ JwtUserPrincipal
│  ├─ SecurityUserService
│  └─ PasswordEncoderConfig
│
├─ service
│  ├─ auth
│  │  ├─ AuthService
│  │  └─ TokenService
│  ├─ chat
│  │  ├─ ChatService
│  │  └─ MessageService
│  ├─ llm
│  │  ├─ LlmClient (interface)
│  │  ├─ LlmService
│  │  ├─ PromptBuilder
│  │  └─ impl
│  │     └─ OpenAiLlmClient (adapter)
│  └─ (B) rag
│     ├─ Retriever (interface)
│     ├─ IngestService
│     ├─ CitationService
│     └─ vector
│        └─ VectorStoreClient
│
├─ vo
│  └─ chat
│     └─ StreamEventVo
│
└─ LandingApplication
```

---

## 5. 後端統一回傳格式（Result Envelope）

### 5.1 成功回傳格式
```json
{
  "success": true,
  "code": "OK",
  "message": "success",
  "data": {},
  "path": "/api/chats",
  "timestamp": "2025-12-30T09:00:00+08:00",
  "traceId": "9f4c2b..."
}
```

### 5.2 失敗回傳格式
```json
{
  "success": false,
  "code": "CHAT_NOT_FOUND",
  "message": "Chat not found",
  "data": {
    "details": "chatId=123"
  },
  "path": "/api/chats/123",
  "timestamp": "2025-12-30T09:00:00+08:00",
  "traceId": "9f4c2b..."
}
```

### 5.3 Result<T> 欄位建議
- `success: boolean`
- `code: string`（搭配 ErrorCode enum）
- `message: string`
- `data: T | object`
- `path: string`
- `timestamp: string`
- `traceId: string`

---

## 6. 後端全域統一錯誤管理（Global Exception Handling）

### 6.1 設計原則
- 所有例外最終由 `@RestControllerAdvice` 攔截
- 統一轉成 `Result.fail(...)`
- Validation error 統一回傳欄位錯誤清單
- 每個回應都帶上 `traceId` 方便對 log 追查

### 6.2 ErrorCode 建議命名
- `OK`
- `VALIDATION_FAILED`
- `AUTH_INVALID_CREDENTIALS`, `AUTH_INVALID_TOKEN`, `AUTH_FORBIDDEN`
- `CHAT_NOT_FOUND`, `CHAT_ACCESS_DENIED`
- `LLM_TIMEOUT`, `LLM_PROVIDER_ERROR`, `LLM_QUOTA_EXCEEDED`
- `RATE_LIMITED`
- `INTERNAL_ERROR`

### 6.3 Validation error 回傳示例
```json
{
  "success": false,
  "code": "VALIDATION_FAILED",
  "message": "Validation failed",
  "data": {
    "fields": [
      { "field": "email", "reason": "must be a well-formed email address" },
      { "field": "password", "reason": "size must be between 8 and 64" }
    ]
  },
  "path": "/api/auth/register",
  "timestamp": "...",
  "traceId": "..."
}
```

---

## 7. SSE 串流協議（像 GPT 打字）

### 7.1 事件類型（固定 schema）
- `event: delta`：逐段文字片段
- `event: meta`：附加資訊（B 的 citations / chunks；A 可不送）
- `event: done`：完成（含 token usage）
- `event: error`：串流錯誤（內含 Result.fail 物件）

### 7.2 事件 payload 範例

**delta**
```json
{ "type": "delta", "delta": "你好，" }
```

**meta（B 才會用）**
```json
{
  "type": "meta",
  "citations": [
    { "docId": 10, "chunkId": 88, "title": "Spec.pdf", "page": 3 }
  ]
}
```

**done**
```json
{
  "type": "done",
  "usage": { "inputTokens": 123, "outputTokens": 456 }
}
```

**error**
```json
{
  "type": "error",
  "error": {
    "success": false,
    "code": "LLM_TIMEOUT",
    "message": "Model request timeout",
    "data": {},
    "path": "/api/chats/1/messages:stream",
    "timestamp": "...",
    "traceId": "..."
  }
}
```

### 7.3 SSE 端點建議
- `POST /api/chats/{chatId}/messages:stream`
  - Request body：`content`,（可選）`model`, `temperature`, `maxTokens`
  - Response：`text/event-stream`

> 備註：也可以拆成 `POST message` + `GET stream`，但 MVP 一支端點最快落地。

---

## 8. API 規格（A 版）

> 所有非串流 API 回傳都使用 `Result<T>` envelope。

### 8.1 Auth
- `POST /api/auth/register`  
  - req：`RegisterReq { email, password, displayName }`
  - resp：`Result<AuthMeResp>`
- `POST /api/auth/login`  
  - req：`LoginReq { email, password }`
  - resp：`Result<AuthMeResp>`（並設定 JWT cookie 或回傳 token）
- `POST /api/auth/logout`  
  - resp：`Result<Void>`
- `GET /api/auth/me`  
  - resp：`Result<AuthMeResp>`

### 8.2 Chat
- `POST /api/chats`  
  - req：`ChatCreateReq { title? }`
  - resp：`Result<ChatResp>`
- `GET /api/chats`  
  - resp：`Result<List<ChatResp>>`
- `GET /api/chats/{chatId}`  
  - resp：`Result<ChatDetailResp>`（含 messages）
- `DELETE /api/chats/{chatId}`（optional）
  - resp：`Result<Void>`

### 8.3 Message（串流）
- `POST /api/chats/{chatId}/messages:stream`  
  - req：`MessageSendReq { content, model?, temperature? }`
  - resp：SSE events（delta/meta/done/error）

---

## 9. 資料庫設計（A 版，MySQL 8）

### 9.1 users（最小欄位）
- `id` (PK)
- `email` (unique)
- `password_hash`
- `display_name`
- `status`
- `created_at`, `updated_at`

### 9.2 chats
- `id` (PK)
- `user_id` (FK -> users.id)
- `title`
- `created_at`, `updated_at`

### 9.3 messages（A 就先預留 B 的擴充欄位）
- `id` (PK)
- `chat_id` (FK -> chats.id)
- `role` (`system|user|assistant`)
- `content` (TEXT)
- `provider` (nullable)
- `model` (nullable)
- `token_in` (nullable)
- `token_out` (nullable)
- `metadata_json` (JSON) ✅（B 的 citations、tool output、參數都放這）
- `created_at`

> 建議：`metadata_json` 的結構保持向後相容（新增欄位不破壞既有）。

---

## 10. 前端專案架構（Vue 3，不用 Tailwind）

### 10.1 目錄結構
```
src/
├─ api/
│  ├─ http.ts              (Axios instance + interceptors)
│  ├─ error.ts             (AppError 正規化)
│  ├─ auth.api.ts
│  └─ chat.api.ts
│
├─ stores/
│  ├─ auth.store.ts
│  └─ chat.store.ts
│
├─ router/
│  └─ index.ts
│
├─ views/
│  ├─ LoginPage.vue
│  └─ ChatPage.vue
│
├─ components/
│  └─ chat/
│     ├─ Sidebar.vue       (對話列表、搜尋、建立)
│     ├─ Thread.vue        (訊息串)
│     ├─ MessageBubble.vue (Markdown + code copy)
│     └─ Composer.vue      (輸入框、送出、Stop)
│
├─ styles/
│  ├─ base.scss            (reset、基本排版)
│  ├─ variables.scss       (色票、間距、圓角、陰影)
│  └─ layout.scss          (layout primitives)
│
└─ utils/
   ├─ sse.ts               (SSE client 封裝)
   └─ markdown.ts
```

### 10.2 CSS 策略（非 Tailwind）
- 全域：`base.scss` + `variables.scss`（像 design tokens）
- 版面：`layout.scss`（container、grid、split layout 等）
- 元件：建議用 CSS Modules 或 BEM，避免 class 衝突

---

## 11. 前端 Axios 封裝（統一 API 與錯誤處理）

### 11.1 設計目標
- 所有 API request 都從 `api/http.ts` 走
- 成功：直接回傳 `Result.data`（或保留全包裝，依偏好）
- 失敗：統一轉成 `AppError`（UI 只處理一種錯誤物件）
- 401：可統一導向登入或觸發 refresh（若你後續做 refresh token）
- Validation：把 fields errors 保留下來，方便表單顯示

### 11.2 後端 Result 與前端錯誤映射
後端回應（非 2xx 或 success=false）→ 前端統一變成：
- `AppError.code`
- `AppError.message`
- `AppError.traceId`
- `AppError.fieldErrors?`（若是 VALIDATION_FAILED）

### 11.3 前端錯誤呈現策略
- 表單類：顯示欄位錯誤（fieldErrors）
- 系統類：Toast/ElMessage 顯示 message + traceId（便於除錯）
- 串流類：在訊息泡泡下面顯示「生成失敗，可重試」

---

## 12. A 版串流互動（前端行為規格）

### 12.1 ChatThread 行為
- 使用者送出後，先把 user message append 到 UI（optimistic）
- 建立一個 assistant message（空 content）並開始接收 SSE `delta` 拼接內容
- 收到 `done`：鎖定訊息、同步刷新 chat detail（可選）
- Stop：中止 SSE（Abort/close），並在 UI 標註「已停止」

### 12.2 Regenerate（可選）
- 後端可以提供 `POST /api/chats/{id}/messages/{messageId}:regenerate` 或沿用 stream 端點
- 前端以「同一則 assistant message」覆蓋或新增一則 regenerated message（看產品設計）

---

## 13. B 升級（RAG）設計：如何無痛加上去

### 13.1 新增資料表（示意）
- `knowledge_bases`
- `documents`
- `document_chunks`
- （可選）`chunk_embeddings`（若不使用外部向量庫）

### 13.2 新增後端模組（不動 A 核心）
- `service/rag/IngestService`：解析檔案 → chunk → embedding
- `service/rag/Retriever`：向量搜尋 topK chunks
- `service/rag/CitationService`：把 chunks 格式化成 citations（供 meta event & metadata_json）
- `service/rag/vector/VectorStoreClient`：可替換 pgvector / qdrant

### 13.3 Chat 串流流程（A vs B）
- A：
  1) 讀 messages
  2) promptBuilder.build(messages)
  3) llmClient.stream(prompt) → SSE delta
  4) done

- B：
  1) 取 query（使用者訊息）
  2) retriever.retrieve(query) → context + citations
  3) promptBuilder.build(messages, context)
  4) llmClient.stream(prompt) → SSE delta
  5) SSE 發 `meta(citations)`
  6) done
  7) citations 寫入 `messages.metadata_json`

---

## 14. 開發順序（建議）

1) 後端：Auth + chats/messages CRUD（先不接 LLM）  
2) 前端：Chat UI（Sidebar/Thread/Composer）+ CRUD 串接  
3) 後端：LLM gateway（非串流先通）  
4) SSE 串流（delta/done）  
5) 前後端統一錯誤處理（Result + Axios interceptors）完整打通  
6) Stop / Regenerate（可選）  
7) 升級 B：文件 ingest → retrieve → citations meta event

---

## 15. 最小可跑（A 版）必備清單

### 15.1 後端必備類別（建檔順序）
- `result/Result`
- `exception/ErrorCode`, `exception/BizException`, `exception/NotFoundException`
- `handler/GlobalExceptionHandler`
- `filter/TraceIdFilter`
- `security/JwtProvider`, `filter/JwtAuthFilter`, `config/SecurityConfig`
- `entity/User, Chat, Message`
- `repository/UserRepository, ChatRepository, MessageRepository`
- `service/llm/LlmClient`, `service/llm/PromptBuilder`, `service/llm/impl/OpenAiLlmClient`
- `service/chat/ChatService`, `service/chat/MessageService`
- `controller/AuthController`, `controller/ChatController`

### 15.2 前端必備檔案
- `api/http.ts`, `api/error.ts`, `api/auth.api.ts`, `api/chat.api.ts`
- `stores/auth.store.ts`, `stores/chat.store.ts`
- `views/LoginPage.vue`, `views/ChatPage.vue`
- `components/chat/*`
- `utils/sse.ts`, `utils/markdown.ts`
- `styles/base.scss`, `styles/variables.scss`

---

## 16. 附錄：建議的 SSE 事件對應表

| event | type | 用途 | A 是否使用 | B 是否使用 |
|------|------|------|-----------|-----------|
| delta | delta | 回覆逐字拼接 | ✅ | ✅ |
| meta | meta | citations / 額外資料 | ❌（保留） | ✅ |
| done | done | 完成 + usage | ✅ | ✅ |
| error | error | 串流錯誤 | ✅ | ✅ |

---

## 17. 後續擴充（可選）
- 多模型切換（model picker）
- 用量限制（每日 token quota）
- Workspace / share chat link / export
- Tool calling（function calling）
- Admin 後台（usage、ban、模型設定）

---

> 這份架構書已對齊你目前的 package 風格（扁平＋小模組子資料夾），並確保 A → B 擴展時低耦合、好維護。  
